from bisect import insort
import os
from rake_nltk import Rake
import random
import re
from textblob import TextBlob

_CHAR_LIST = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"


class DirNotFound(Exception):
    """Raised if a directory does not exist"""


def random_string(n):
    """
    Generates a string of random characters.

    Args:
        n (int): Length of string.

    Returns:
        str: The randomly generated string.
    """
    s = "".join((random.choice(_CHAR_LIST) for i in range(n)))
    return s


def get_random_path(root, ext=None):
    """
    Args:
        root (str): Directory to generate path within.
        ext (str): File extension for the random path. None for no extension.

    Returns:
        str: A random, unique path within the provided root directory.

    Raises:
        DirectoryNotFound: If root directory does not exist.
    """
    if not os.path.isdir(root):
        raise DirNotFound
    while True:
        rand_str = random_string(10)
        if ext is None:
            name = rand_str
        else:
            name = "{}.{}".format(rand_str, ext)
        path = os.path.join(root, name)
        if not os.path.exists(path):
            return path


def _join_tags(tags):
    """
    Join words/tags generated by `TextBlob`.

    A simple `join` operation can lead to whitespace in undesirable places, such as in the middle
    of contractions. This helper methods properly handles these cases.

    Args:
        tags (list): Tags created by `TextBlob`.

    Returns:
        str: The sentence(s) created by the tags.
    """
    words = []
    for word, tag in tags:
        if tag[:2] in ("RB", "VB", "MD"):
            if "'" in word[: len(word) - 1]:
                # This word is part of a contraction. We re-combine it here.
                if len(words) > 0:
                    words[-1] += word
                    continue
        words.append(word)
    return " ".join(words)


def shorten_title(title, max_title_len, alpha_only=True):
    """
    Shortens a title using important phrases and keywords in the title.

    Args:
        title (str): Title to shorten.
        max_title_len (int): Maximum length of the final title.
        alpha_only (bool): Whether to only use alphabetic characters.

    Returns:
        str: Shortened, all lower-case title with a length less than `max_title_len`.
    """
    title = title.lower()
    if len(title) <= max_title_len:
        # Title is already short enough.
        return title

    blob = TextBlob(title)
    if len(blob.sentences) == 1:
        first_blob = blob
    else:
        first_blob = blob.sentences[0]
    tags_kept = []
    for word, tag in first_blob.tags:
        if tag != "DT":
            tags_kept.append((word, tag))
    new_title = _join_tags(tags_kept)
    if len(new_title) <= max_title_len:
        return new_title

    if alpha_only:
        filter = re.compile("[^a-z ]")
        title = filter.sub("", title)

    # Try using the highest ranked phrase from the title.
    r = Rake()
    r.extract_keywords_from_text(title)
    new_title = r.get_ranked_phrases()[0]
    if len(new_title) <= max_title_len:
        return new_title

    # Title is still too long. Use as many of the important words as will fit within the max
    # title length.
    words = sorted(r.get_word_degrees())
    new_title = words[0]
    if len(new_title) > max_title_len:
        # Cut the single-word title short.
        return new_title[:max_title_len]

    for w in words[1:]:
        append_title = "{} {}".format(new_title, w)
        if len(append_title) > max_title_len:
            break
        new_title = append_title

    return new_title


def extract_tags(
    videos, blocklist=None, max_tag_len=0, max_total_chars=0, max_total_tags=0
):
    """
    Creates tags from a list of videos.

    Args:
        videos (list): List videos as `rvidmaker.videos.VideoRef`s. Tags are extracted from
            their titles.
        blocklist (better_profanity.Profanity): Filters out tags with undesirable words or phrases.
            `None` to not perform any filtering.
        max_tag_len (int): Maximum character length of a tag. 0 for no maximum length.
        max_total_chars (int): Maximum total number of characters. 0 for no limit.
        max_total_tags (int): Maximum total character length. 0 for no limit.
    """
    ranked_tags = []
    filter = re.compile("[^a-z ]")
    r = Rake()
    for v in videos:
        title = filter.sub("", v.title.lower())
        r.extract_keywords_from_text(title)
        phrases = r.get_ranked_phrases_with_scores()
        for score, phrase in phrases:
            if score <= 1:
                continue
            if max_tag_len > 0 and len(phrase) > max_tag_len:
                continue
            if blocklist is not None:
                if blocklist.contains_profanity(phrase):
                    continue
            insort(ranked_tags, (score, phrase))
    tags = set()
    total_chars = 0
    for _, tag in reversed(ranked_tags):
        if max_total_chars > 0:
            total_chars += len(tag)
            if total_chars >= max_total_chars:
                break
        tags.add(tag)
        if max_total_tags > 0 and len(tags) >= max_total_tags:
            break
    return tags


class TomlGetCheckException(Exception):
    """Raised when TOML value type checks fail"""


_to_toml_type = {
    bool: "boolean",
    float: "float",
    int: "integer",
    list: "array",
    str: "string",
}


def toml_get_and_check(
    d, key, field_type, item_type=None, default=None, required=False
):
    """
    Gets a value from a dictionary and checks its value.
    Intended for use with TOML generated dictionaries.

    Args:
        d (dict): Dictionary generated by `toml`.
        key (str): Name of the field.
        field_type (type): The field's type. Only supports `bool`, `float`,
            `int`, `list`, `str`, where `list` if for arrays.
        item_type (type): Type of value inside a list. Only used if
            `field_type` is `list`.
        default: Optional default value if the field is not found.
        required: Whether to throw an error if the field is not found.

    Returns:
        The value if it exists and is of the correct type, and `None` if the
        key is not found in the dictionary.

    Raises:
        TomlGetCheckException: If the field does not match its type.
    """
    value = d.get(key)
    if value is None:
        if required:
            raise TomlGetCheckException('The "{}" field is required'.format(key))
        elif default is not None:
            value = default
    elif value:
        if type(value) != field_type:
            raise TomlGetCheckException(
                'The "{}" field must be of type {}'.format(
                    key,
                    _to_toml_type[field_type],
                )
            )
        elif field_type == list and len(value) > 0 and type(value[0]) != item_type:
            raise TomlGetCheckException(
                'The "{}" field\'s items must be of type {}'.format(
                    key,
                    _to_toml_type[item_type],
                )
            )
    return value
